{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"I am a Math, Stats, CS student at the University of Toronto (St. George) , who loves to use diverse algorithms and mathematics to solve difficult problems. In my free time, I love to golf and work on these . I previously attended The Albany Academies where I spent my Grade 12 and Post Graduate year in New York with the opportunity to travel across the United States and play high-level hockey. I captained the Varsity Hockey Team and was involved in various activities such as Robotics Club, Student Ambassadors, Math Tutoring and was a Teacher Assistant for a 2nd Grade Class. Work Experience Data Intern at Interac Corp. May 2021 - September 2021 Used Python to access Jira API to connect employee's tasks, task life and other statistics with Planview for work management. Used Tableau to connect and efficiently display and analyze employee's time-sheets Created and organized newsletter for department highlighting data analytic leaders, data culture and educational resources. Web Developer at SSD Group LTD. May 2020 - May 2021 Developed and designed a dynamic website using React and Node.js. Automated incoming orders for PPE products. Maintained upkeep of hosting and created a fully functional contact form that filtered responses into a Google Sheet. Skills Languages Python, SQL (Postgres), JavaScript, HTML/CSS, R Frameworks React, Node.js, Flask, MongoDB, WordPress Developer Tools Git, Docker, Google Cloud Platform, VS Code, Visual Studio, PyCharm, IntelliJ Libraries pandas, patsy, statsmodels, NumPy, Matplotlib This Site This site was built using MkDocs which is a Python-based static site generator that uses markdown to create all the material shown on the site. I chose MkDocs as it is easy to deploy and allows for quick, live edits.","title":"Home"},{"location":"#work-experience","text":"Data Intern at Interac Corp. May 2021 - September 2021 Used Python to access Jira API to connect employee's tasks, task life and other statistics with Planview for work management. Used Tableau to connect and efficiently display and analyze employee's time-sheets Created and organized newsletter for department highlighting data analytic leaders, data culture and educational resources. Web Developer at SSD Group LTD. May 2020 - May 2021 Developed and designed a dynamic website using React and Node.js. Automated incoming orders for PPE products. Maintained upkeep of hosting and created a fully functional contact form that filtered responses into a Google Sheet.","title":"Work Experience"},{"location":"#skills","text":"","title":"Skills"},{"location":"#languages","text":"Python, SQL (Postgres), JavaScript, HTML/CSS, R","title":"Languages"},{"location":"#frameworks","text":"React, Node.js, Flask, MongoDB, WordPress","title":"Frameworks"},{"location":"#developer-tools","text":"Git, Docker, Google Cloud Platform, VS Code, Visual Studio, PyCharm, IntelliJ","title":"Developer Tools"},{"location":"#libraries","text":"pandas, patsy, statsmodels, NumPy, Matplotlib","title":"Libraries"},{"location":"#this-site","text":"This site was built using MkDocs which is a Python-based static site generator that uses markdown to create all the material shown on the site. I chose MkDocs as it is easy to deploy and allows for quick, live edits.","title":"This Site"},{"location":"work/","text":"Work A lot of my work is geared towards undergraduate mathematics and a variety of projects using machine learning. My knowledge of statistics and computer science are used in hopes of creating meaningful, educational resources for others. Statistics with Python Predictions Wildfire Predictor (School Project) The main goal of this project was to predict the wildfire count for any state in the U.S. in any given year using a poisson regression model and a negative binomial regression model. Two models were used because either regression suits the situation as we were looking for discrete outcomes. The poisson regression was created with the following code: df = pd . DataFrame . from_dict ( data [ state ], orient = 'index' , columns = [ 'Average_Temp' , 'Precipitation' , 'Fire_Counts' ]) # Creating a regression variable for the Year df [ 'Year' ] = df . index # Creates a random sample from a uniform distribution rand_samples = np . random . rand ( len ( df )) < 0.8 # Training dataset df_train = df [ rand_samples ] # Testing dataset df_test = df [ ~ rand_samples ] # Regression expression in Patsy Notation equation = \"\"\"Fire_Counts ~ Average_Temp + Precipitation + Year\"\"\" # Creating matrices for the training datasets w/ Patsy y_train , x_train = dmatrices ( equation , df_train , return_type = 'dataframe' ) # Creating matrices for the testing datasets w/ Patsy y_test , x_test = dmatrices ( equation , df_test , return_type = 'dataframe' ) # Using statsmodels GLM class to train the regression poisson_results = sm . GLM ( y_train , x_train , family = sm . families . Poisson ()) . fit () poisson_predictions = poisson_results . get_prediction ( x_test ) # Returning a pandas DF w .summary_frame() predictions_summary_frame = poisson_predictions . summary_frame () # Extracting the mean values for predicted counts predicted_counts = predictions_summary_frame [ 'mean' ] actual_counts = y_test [ 'Fire_Counts' ] Then we just created a plot using matplotlib and it allowed us to project the results. For the negative binomial regression, it is very similar except now we are adding the lambda vector as a new column in our dataframe after we have trained the regression: df_train [ 'Count_Mean' ] = poisson_results . mu # Add a column to store values of dependent variable df_train [ 'OLS_Variable' ] = df_train . apply ( lambda x : (( x [ 'Fire_Counts' ] - x [ 'Count_Mean' ]) ** 2 - x [ 'Count_Mean' ]) / x [ 'Count_Mean' ], axis = 1 ) # Model specification for OSL Regression ols_equation = \"\"\"OLS_Variable ~ Count_Mean - 1\"\"\" ols_reg_results = smf . ols ( ols_equation , df_train ) . fit () nb2_training_results = sm . GLM ( y_train , x_train , family = sm . families . NegativeBinomial ( alpha = ols_reg_results . params [ 0 ])) . fit () nb2_predictions = nb2_training_results . get_prediction ( x_test ) predictions_summary_frame = nb2_predictions . summary_frame () Then we are able to plot using matplotlib once again to plot and compare predicted versus actual counts. Code Math with Python Project Euler These are a collection of solutions and workthroughs for my problems to Project Euler. All credit goes to them for their problems. You can check them out with the button below. Euler Even Fibonacci Numbers Problem 2 Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: $$ 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... s$$ By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms. k , q = 1 , 1 total = 0 while k <= 4000000 : if k % 2 == 0 : total += k k , q = q , k + q print ( total ) This is pretty straightforward, we ar Linear Algebra Matrix Multiplication Matrix multiplication can be pretty hard at first but there are only two properties we need to keep in mind: For matrices \\(A\\) and \\(B,\\) in order for \\(AB\\) to be defined the number of columns of \\(A\\) must be equal to the number of rows of \\(B.\\) The product of an \\(n \\times m\\) matrix and an \\(m \\times q\\) matrix is an \\(n \\times q\\) matrix. V1 The first approach uses zip(*) to separate the elements of each list into a list of tuples into independent sequences that allows us to access the columns of our second matrix. Then we can just find the product of the rows and columns. zipped_second = list ( zip ( * second_matrix )) return [[ sum ( a * b for a , b in zip ( row_a , col_b )) for col_b in zipped_second ] for row_a in first_matrix ] V2 with NumPy Using NumPy is pretty easy as the the built-in numpy.dot() allows us to take the dot product of the two arrays. first_m = np . array ( first_matrix ) second_m = np . array ( second_matrix ) return np . dot ( first_m , second_m ) The Rank of a Matrix There is a couple ways to define the rank of a matrix. If \\(M\\) is a matrix then we know that the rank of \\(M\\) is equal to the number of pivots in \\(\\operatorname{rref}(M).\\) If our matrix is a nested list, we can use SymPy to convert our matrix into row-reduced echelon form by using rref() and then just returning the number of pivots in our matrix. rref_matrx = sympy . Matrix ( matrx ) . rref () return len ( rref_matrx [ - 1 ]) We reference the back of the list here as the end of the list will be a tuple of the pivots from our matrix. Row Reduced Echelon Form Row reduced echelon form has many purposes: invert matrices, compute determinants, solve systems of linear equations and more. So now onto our definition. A matrix is in row reduced echelon form if: All zero rows are at the bottom. The first nonzero entry of a row is to the right of the first nonzero entry of the row above. Below the first nonzero entry of a row, all entries are zero. (Note: This does require NumPy.) Gaussian elimination is fairly recursive and if you understand how the algorithm works for row reducing a matrix then the code should be fairly straight forward. Below the code snippet I've made comments explaining the thought process if you want to understand more. def rreform ( matrx ): \"\"\"I want to return the row reduced echelon form of the given matrix.\"\"\" # Refer to A row , col = matrx . shape if row == 0 or col == 0 : return matrx # Refer to B for n in range ( len ( matrx )): if matrx [ n , 0 ] != 0 : break # Refer to C else : rref_matrix = rreform ( matrx [:, 1 :]) return numpy . hstack ([ matrx [:, : 1 ], rref_matrix ]) # Refer to D if n > 0 : nth_row = matrx [ n ] . copy () matrx [ n ] = matrx [ 0 ] matrx [ 0 ] = nth_row # Refer to E matrx [ 0 ] = matrx [ 0 ] / matrx [ 0 , 0 ] matrx [ 1 :] -= matrx [ 0 ] * matrx [ 1 :, 0 : 1 ] rref_matrix = rreform ( matrx [ 1 :, 1 :]) return numpy . vstack ([ matrx [: 1 ], numpy . hstack ([ matrx [ 1 :, : 1 ], rref_matrix ])]) A: This is a checking point for determining if the matrix has no columns or rows, which would allow us to conclude it is in row reduced echelon form and the matrix can be returned. matrx.shape gives us back a tuple of the form (rows, columns). B: In the given matrix, we are trying to find the first nonzero entry in the first column. C: At this point, we have to realize that if all the entries in the first column are zero then we can recursively call our function onto the next column and then add the previous checked column back to the matrix. D: This if statement is used to cover all the bases, meaning if all the entries are 0 in a certain row then we need to find the row that contains a nonzero entry. E: This step is the operations of row reduction, in the first line we are dividing the first row by the first element and then we are subtracting the other rows with the first row multiplied by the entry in the first column. We do this because now the first entry is a 1 and this is generally one of the first things you want to do with row reduction. Then we just call our function again on the second row and add our rows and columns back to our matrix.","title":"Work"},{"location":"work/#work","text":"A lot of my work is geared towards undergraduate mathematics and a variety of projects using machine learning. My knowledge of statistics and computer science are used in hopes of creating meaningful, educational resources for others.","title":"Work"},{"location":"work/#statistics-with-python","text":"","title":"Statistics with Python"},{"location":"work/#predictions","text":"","title":"Predictions"},{"location":"work/#wildfire-predictor-school-project","text":"The main goal of this project was to predict the wildfire count for any state in the U.S. in any given year using a poisson regression model and a negative binomial regression model. Two models were used because either regression suits the situation as we were looking for discrete outcomes. The poisson regression was created with the following code: df = pd . DataFrame . from_dict ( data [ state ], orient = 'index' , columns = [ 'Average_Temp' , 'Precipitation' , 'Fire_Counts' ]) # Creating a regression variable for the Year df [ 'Year' ] = df . index # Creates a random sample from a uniform distribution rand_samples = np . random . rand ( len ( df )) < 0.8 # Training dataset df_train = df [ rand_samples ] # Testing dataset df_test = df [ ~ rand_samples ] # Regression expression in Patsy Notation equation = \"\"\"Fire_Counts ~ Average_Temp + Precipitation + Year\"\"\" # Creating matrices for the training datasets w/ Patsy y_train , x_train = dmatrices ( equation , df_train , return_type = 'dataframe' ) # Creating matrices for the testing datasets w/ Patsy y_test , x_test = dmatrices ( equation , df_test , return_type = 'dataframe' ) # Using statsmodels GLM class to train the regression poisson_results = sm . GLM ( y_train , x_train , family = sm . families . Poisson ()) . fit () poisson_predictions = poisson_results . get_prediction ( x_test ) # Returning a pandas DF w .summary_frame() predictions_summary_frame = poisson_predictions . summary_frame () # Extracting the mean values for predicted counts predicted_counts = predictions_summary_frame [ 'mean' ] actual_counts = y_test [ 'Fire_Counts' ] Then we just created a plot using matplotlib and it allowed us to project the results. For the negative binomial regression, it is very similar except now we are adding the lambda vector as a new column in our dataframe after we have trained the regression: df_train [ 'Count_Mean' ] = poisson_results . mu # Add a column to store values of dependent variable df_train [ 'OLS_Variable' ] = df_train . apply ( lambda x : (( x [ 'Fire_Counts' ] - x [ 'Count_Mean' ]) ** 2 - x [ 'Count_Mean' ]) / x [ 'Count_Mean' ], axis = 1 ) # Model specification for OSL Regression ols_equation = \"\"\"OLS_Variable ~ Count_Mean - 1\"\"\" ols_reg_results = smf . ols ( ols_equation , df_train ) . fit () nb2_training_results = sm . GLM ( y_train , x_train , family = sm . families . NegativeBinomial ( alpha = ols_reg_results . params [ 0 ])) . fit () nb2_predictions = nb2_training_results . get_prediction ( x_test ) predictions_summary_frame = nb2_predictions . summary_frame () Then we are able to plot using matplotlib once again to plot and compare predicted versus actual counts. Code","title":"Wildfire Predictor (School Project)"},{"location":"work/#math-with-python","text":"","title":"Math with Python"},{"location":"work/#project-euler","text":"These are a collection of solutions and workthroughs for my problems to Project Euler. All credit goes to them for their problems. You can check them out with the button below. Euler","title":"Project Euler"},{"location":"work/#even-fibonacci-numbers","text":"Problem 2 Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: $$ 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... s$$ By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms. k , q = 1 , 1 total = 0 while k <= 4000000 : if k % 2 == 0 : total += k k , q = q , k + q print ( total ) This is pretty straightforward, we ar","title":"Even Fibonacci Numbers"},{"location":"work/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"work/#matrix-multiplication","text":"Matrix multiplication can be pretty hard at first but there are only two properties we need to keep in mind: For matrices \\(A\\) and \\(B,\\) in order for \\(AB\\) to be defined the number of columns of \\(A\\) must be equal to the number of rows of \\(B.\\) The product of an \\(n \\times m\\) matrix and an \\(m \\times q\\) matrix is an \\(n \\times q\\) matrix.","title":"Matrix Multiplication"},{"location":"work/#v1","text":"The first approach uses zip(*) to separate the elements of each list into a list of tuples into independent sequences that allows us to access the columns of our second matrix. Then we can just find the product of the rows and columns. zipped_second = list ( zip ( * second_matrix )) return [[ sum ( a * b for a , b in zip ( row_a , col_b )) for col_b in zipped_second ] for row_a in first_matrix ]","title":"V1"},{"location":"work/#v2-with-numpy","text":"Using NumPy is pretty easy as the the built-in numpy.dot() allows us to take the dot product of the two arrays. first_m = np . array ( first_matrix ) second_m = np . array ( second_matrix ) return np . dot ( first_m , second_m )","title":"V2 with NumPy"},{"location":"work/#the-rank-of-a-matrix","text":"There is a couple ways to define the rank of a matrix. If \\(M\\) is a matrix then we know that the rank of \\(M\\) is equal to the number of pivots in \\(\\operatorname{rref}(M).\\) If our matrix is a nested list, we can use SymPy to convert our matrix into row-reduced echelon form by using rref() and then just returning the number of pivots in our matrix. rref_matrx = sympy . Matrix ( matrx ) . rref () return len ( rref_matrx [ - 1 ]) We reference the back of the list here as the end of the list will be a tuple of the pivots from our matrix.","title":"The Rank of a Matrix"},{"location":"work/#row-reduced-echelon-form","text":"Row reduced echelon form has many purposes: invert matrices, compute determinants, solve systems of linear equations and more. So now onto our definition. A matrix is in row reduced echelon form if: All zero rows are at the bottom. The first nonzero entry of a row is to the right of the first nonzero entry of the row above. Below the first nonzero entry of a row, all entries are zero. (Note: This does require NumPy.) Gaussian elimination is fairly recursive and if you understand how the algorithm works for row reducing a matrix then the code should be fairly straight forward. Below the code snippet I've made comments explaining the thought process if you want to understand more. def rreform ( matrx ): \"\"\"I want to return the row reduced echelon form of the given matrix.\"\"\" # Refer to A row , col = matrx . shape if row == 0 or col == 0 : return matrx # Refer to B for n in range ( len ( matrx )): if matrx [ n , 0 ] != 0 : break # Refer to C else : rref_matrix = rreform ( matrx [:, 1 :]) return numpy . hstack ([ matrx [:, : 1 ], rref_matrix ]) # Refer to D if n > 0 : nth_row = matrx [ n ] . copy () matrx [ n ] = matrx [ 0 ] matrx [ 0 ] = nth_row # Refer to E matrx [ 0 ] = matrx [ 0 ] / matrx [ 0 , 0 ] matrx [ 1 :] -= matrx [ 0 ] * matrx [ 1 :, 0 : 1 ] rref_matrix = rreform ( matrx [ 1 :, 1 :]) return numpy . vstack ([ matrx [: 1 ], numpy . hstack ([ matrx [ 1 :, : 1 ], rref_matrix ])]) A: This is a checking point for determining if the matrix has no columns or rows, which would allow us to conclude it is in row reduced echelon form and the matrix can be returned. matrx.shape gives us back a tuple of the form (rows, columns). B: In the given matrix, we are trying to find the first nonzero entry in the first column. C: At this point, we have to realize that if all the entries in the first column are zero then we can recursively call our function onto the next column and then add the previous checked column back to the matrix. D: This if statement is used to cover all the bases, meaning if all the entries are 0 in a certain row then we need to find the row that contains a nonzero entry. E: This step is the operations of row reduction, in the first line we are dividing the first row by the first element and then we are subtracting the other rows with the first row multiplied by the entry in the first column. We do this because now the first entry is a 1 and this is generally one of the first things you want to do with row reduction. Then we just call our function again on the second row and add our rows and columns back to our matrix.","title":"Row Reduced Echelon Form"}]}