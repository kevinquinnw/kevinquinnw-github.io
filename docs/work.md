# Work
A lot of my work is geared towards undergraduate mathematics and a variety of projects using machine learning. My knowledge of statistics and computer science are used in hopes of creating meaningful, educational resources for others.

## Statistics with Python
### Predictions
---
#### Wildfire Predictor (School Project)
<div style="text-align:center">
<img src="/img/cwf.png" />
</div> 

The main goal of this project was to predict the wildfire count for any state in the U.S. in any given year using a poisson regression model and a negative binomial regression model.

Two models were used because either regression suits the situation as we were looking for discrete outcomes. The poisson regression was created with the following code: 

```python
df = pd.DataFrame.from_dict(data[state], orient='index', columns=['Average_Temp', 'Precipitation', 'Fire_Counts'])
# Creating a regression variable for the Year
df['Year'] = df.index

# Creates a random sample from a uniform distribution
rand_samples = np.random.rand(len(df)) < 0.8

# Training dataset
df_train = df[rand_samples]

# Testing dataset
df_test = df[~rand_samples]

# Regression expression in Patsy Notation
equation = """Fire_Counts ~ Average_Temp + Precipitation + Year"""

# Creating matrices for the training datasets w/ Patsy
y_train, x_train = dmatrices(equation, df_train, return_type='dataframe')

# Creating matrices for the testing datasets w/ Patsy
y_test, x_test = dmatrices(equation, df_test, return_type='dataframe')

# Using statsmodels GLM class to train the regression
poisson_results = sm.GLM(y_train, x_train, family=sm.families.Poisson()).fit()
poisson_predictions = poisson_results.get_prediction(x_test)

# Returning a pandas DF w .summary_frame()
predictions_summary_frame = poisson_predictions.summary_frame()

# Extracting the mean values for predicted counts
predicted_counts = predictions_summary_frame['mean']
actual_counts = y_test['Fire_Counts']
```

Then we just created a plot using matplotlib and it allowed us to project the results. 

For the negative binomial regression, it is very similar except now we are adding the lambda vector as a new column in our dataframe after we have trained the regression: 

```python
df_train['Count_Mean'] = poisson_results.mu

# Add a column to store values of dependent variable
df_train['OLS_Variable'] = df_train.apply(
    lambda x: ((x['Fire_Counts'] - x['Count_Mean']) ** 2 - x['Count_Mean']) / x['Count_Mean'], axis=1)

# Model specification for OSL Regression
ols_equation = """OLS_Variable ~ Count_Mean - 1"""
ols_reg_results = smf.ols(ols_equation, df_train).fit()

nb2_training_results = sm.GLM(y_train, x_train,
                              family=sm.families.NegativeBinomial(alpha=ols_reg_results.params[0])).fit()

nb2_predictions = nb2_training_results.get_prediction(x_test)
predictions_summary_frame = nb2_predictions.summary_frame()
```

Then we are able to plot using matplotlib once again to plot and compare predicted versus actual counts. 

[Code :material-github:](https://github.com/kevinquinnw/wildfire-predictor){ .md-button .md-button--primary target=_blank}


## Math with Python

### Project Euler

These are a collection of solutions and workthroughs for my problems to Project Euler. All credit goes to them for their problems. You can check them out with the button below.

[Euler :octicons-mortar-board-16:](https://projecteuler.net/){ .md-button .md-button--primary target=_blank}

---

#### Even Fibonacci Numbers

> Problem 2
>>
> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
>  $$ 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... s$$
> By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.


```python
k, q = 1, 1 
total = 0 
while k <= 4000000:
    if k % 2 == 0:
        total += k
    k, q = q, k + q
print (total)
```

This is pretty straightforward, we ar

### Linear Algebra
---
#### Matrix Multiplication
Matrix multiplication can be pretty hard at first but there are only two properties we need to keep in mind:    

1. For matrices $A$ and $B,$ in order for $AB$ to be defined the number of columns of $A$ must be equal to the number of rows of $B.$      
2. The product of an $n \times m$ matrix and an $m \times q$ matrix is an $n \times q$ matrix. 


##### V1
The first approach uses `zip(*)` to separate the elements of each list into a list of tuples into independent sequences that allows us to access the columns of our second matrix. Then we can just find the product of the rows and columns.

```python
zipped_second = list(zip(*second_matrix))
    return [[sum(a * b for a, b in zip(row_a, col_b))
             for col_b in zipped_second] for row_a in first_matrix]
```


##### V2 with NumPy
Using NumPy is pretty easy as the the built-in `numpy.dot()` allows us to take the dot product of the two arrays.

```python
first_m = np.array(first_matrix)
second_m = np.array(second_matrix)
    return np.dot(first_m, second_m)
```

---
#### The Rank of a Matrix
There is a couple ways to define the rank of a matrix. If $M$ is a matrix then we know that the rank of $M$ is equal to the number of pivots in $\operatorname{rref}(M).$ 

If our matrix is a nested list, we can use SymPy to convert our matrix into row-reduced echelon form by using `rref()` and then just returning the number of pivots in our matrix. 

```python 
rref_matrx = sympy.Matrix(matrx).rref()
    return len(rref_matrx[-1])
```

We reference the back of the list here as the end of the list will be a tuple of the pivots from our matrix.

---

#### Row Reduced Echelon Form

Row reduced echelon form has many purposes: invert matrices, compute determinants, solve systems of linear equations and more. So now onto our definition. A matrix is in row reduced echelon form if:

1. All zero rows are at the bottom.
2. The first nonzero entry of a row is to the right of the first nonzero entry of the row above.
3. Below the first nonzero entry of a row, all entries are zero. 

(Note: This does require NumPy.) Gaussian elimination is fairly recursive and if you understand how the algorithm works for row reducing a matrix then the code should be fairly straight forward. Below the code snippet I've made comments explaining the thought process if you want to understand more.

```python
def rreform(matrx):
    """I want to return the row reduced echelon form of the given matrix."""
    # Refer to A
    row, col = matrx.shape
    if row == 0 or col == 0:
        return matrx

    # Refer to B
    for n in range(len(matrx)):
        if matrx[n, 0] != 0:
            break
    # Refer to C
    else:
        rref_matrix = rreform(matrx[:, 1:])
        return numpy.hstack([matrx[:, :1], rref_matrix])

    # Refer to D
    if n > 0:
        nth_row = matrx[n].copy()
        matrx[n] = matrx[0]
        matrx[0] = nth_row

    # Refer to E
    matrx[0] = matrx[0] / matrx[0, 0]
    matrx[1:] -= matrx[0] * matrx[1:, 0:1]
    rref_matrix = rreform(matrx[1:, 1:])
    return numpy.vstack([matrx[:1], numpy.hstack([matrx[1:, :1], rref_matrix])])
```

**A:** This is a checking point for determining if the matrix has no columns or rows, which would allow us to conclude it is in row reduced echelon form and the matrix can be returned. `matrx.shape` gives us back a tuple of the form (rows, columns). 

**B:** In the given matrix, we are trying to find the first nonzero entry in the first column.

**C:** At this point, we have to realize that if all the entries in the first column are zero then we can recursively call our function onto the next column and then add the previous checked column back to the matrix. 

**D:** This `if` statement is used to cover all the bases, meaning if all the entries are 0 in a certain row then we need to find the row that contains a nonzero entry. 

**E:** This step is the operations of row reduction, in the first line we are dividing the first row by the first element and then we are subtracting the other rows with the first row multiplied by the entry in the first column. We do this because now the first entry is a 1 and this is generally one of the first things you want to do with row reduction. Then we just call our function again on the second row and add our rows and columns back to our matrix. 
